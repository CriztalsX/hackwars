<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hack Wars</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #000;
            background-image: linear-gradient(
                180deg,
                #000 0%,
                #000 50%,
                #080808 50%,
                #080808 100%
            );
            background-size: 100% 16px;
            background-repeat: repeat;
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid #fff;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 48px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .header .tagline {
            margin-top: 10px;
            opacity: 0.7;
            font-size: 14px;
        }

        /* Login/Register Screen */
        .auth-screen {
            max-width: 500px;
            margin: 100px auto;
            padding: 40px;
            border: 2px solid #fff;
            background: #000;
        }

        .auth-screen h2 {
            margin-bottom: 20px;
            text-align: center;
            font-size: 28px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: #000;
            border: 1px solid #fff;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
        }

        .form-group input:focus {
            outline: none;
            border: 2px solid #fff;
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: #fff;
            color: #000;
            border: 2px solid #fff;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #000;
            color: #fff;
        }

        .btn-secondary {
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background: #fff;
            color: #000;
        }

        .btn-small {
            width: auto;
            padding: 8px 16px;
            font-size: 12px;
        }

        /* Main Game Interface */
        .game-container {
            display: none;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #fff;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            margin-top: 5px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #fff;
        }

        .tab {
            padding: 15px 30px;
            background: #000;
            color: #fff;
            border: 1px solid #fff;
            border-bottom: none;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 1px;
            flex: 1;
            text-align: center;
        }

        .tab.active {
            background: #fff;
            color: #000;
        }

        .tab-content {
            display: none;
            padding: 30px;
            border: 2px solid #fff;
            min-height: 400px;
        }

        .tab-content.active {
            display: block;
        }

        /* Target List */
        .target-list {
            display: grid;
            gap: 15px;
        }

        .target-card {
            padding: 20px;
            border: 1px solid #fff;
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 20px;
        }

        .target-info h3 {
            margin-bottom: 10px;
            font-size: 20px;
        }

        .target-detail {
            font-size: 12px;
            opacity: 0.7;
            margin: 5px 0;
        }

        .target-actions {
            display: flex;
            gap: 10px;
            flex-direction: column;
        }

        /* Shop */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .shop-item {
            padding: 25px;
            border: 2px solid #fff;
            text-align: center;
        }

        .shop-item h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }

        .shop-item .description {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .shop-item .price {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .shop-item.owned {
            opacity: 0.5;
            border-style: dashed;
        }

        /* Clues Display */
        .clues-container {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #fff;
            background: #111;
        }

        .clue-item {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid #fff;
            padding-left: 15px;
            font-size: 14px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #000;
            border: 2px solid #fff;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        .close-modal {
            float: right;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #fff;
            color: #000;
            padding: 20px 30px;
            border: 2px solid #000;
            font-weight: bold;
            z-index: 2000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
            }
            to {
                transform: translateX(0);
            }
        }

        .notification.error {
            background: #000;
            color: #fff;
            border: 2px solid #fff;
        }

        /* Defenses Display */
        .defenses-list {
            display: grid;
            gap: 10px;
            margin-top: 20px;
        }

        .defense-badge {
            padding: 10px 15px;
            border: 1px solid #fff;
            display: inline-block;
            margin: 5px;
            font-size: 12px;
        }

        /* Activity Log */
        .activity-log {
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 15px;
            border-bottom: 1px solid #333;
            font-size: 13px;
        }

        .log-entry .timestamp {
            opacity: 0.5;
            font-size: 11px;
        }

        /* Hide scrollbar but keep functionality */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #fff;
        }

        .password-strength {
            margin-top: 5px;
            font-size: 11px;
            opacity: 0.7;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
        }

        .empty-state {
            text-align: center;
            padding: 50px;
            opacity: 0.5;
        }

        /* Operator Access Link */
        .operator-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 10px;
            opacity: 0.3;
            cursor: pointer;
            transition: opacity 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .operator-link:hover {
            opacity: 0.8;
        }

        /* Operator Panel Styles */
        .operator-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 10000;
            overflow-y: auto;
        }

        .operator-panel.active {
            display: block;
        }

        .operator-header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid #000;
            margin-bottom: 30px;
            background: #fff;
        }

        .operator-header h1 {
            font-size: 48px;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: #000;
        }

        .operator-header .tagline {
            margin-top: 10px;
            opacity: 0.7;
            font-size: 14px;
            color: #000;
        }

        .operator-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            color: #000;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            padding: 20px;
            border: 2px solid #000;
            text-align: center;
            background: #fff;
        }

        .stat-box .value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stat-box .label {
            font-size: 12px;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            border: 2px solid #000;
            background: #fff;
        }

        .section h2 {
            margin-bottom: 20px;
            color: #000;
            font-size: 24px;
        }

        .user-card {
            padding: 15px;
            border: 1px solid #000;
            margin-bottom: 10px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .user-card:hover {
            border-color: #666;
            background: #f0f0f0;
        }

        .user-card.hacked {
            border-color: #f00;
            background: #ffe0e0;
        }

        .danger-zone {
            border-color: #f00;
        }

        .danger-zone h2 {
            color: #f00;
        }

        .btn-danger {
            background: #000;
            color: #f00;
            border: 2px solid #f00;
        }

        .btn-danger:hover {
            background: #f00;
            color: #000;
        }

        .btn-operator {
            background: #000;
            color: #fff;
            border: 2px solid #000;
        }

        .btn-operator:hover {
            background: #fff;
            color: #000;
        }

        .close-operator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #000;
            color: #fff;
            border: 2px solid #000;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-weight: bold;
            z-index: 10001;
        }

        .close-operator:hover {
            background: #fff;
            color: #000;
        }

        /* Operator Password Modal */
        .operator-password-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .operator-password-modal.active {
            display: flex;
        }

        .operator-password-content {
            max-width: 400px;
            width: 90%;
            padding: 40px;
            border: 2px solid #000;
            background: #fff;
        }

        .operator-password-content h2 {
            color: #000;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .operator-password-content input {
            width: 100%;
            padding: 12px;
            background: #fff;
            border: 1px solid #000;
            color: #000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            text-align: center;
            letter-spacing: 8px;
            margin-bottom: 20px;
        }

        .operator-password-content input:focus {
            outline: none;
            border: 2px solid #000;
        }

        .operator-password-buttons {
            display: flex;
            gap: 10px;
        }

        .operator-password-buttons button {
            flex: 1;
            margin: 0; /* Override any default margins */
        }

        /* ============================= */
        /* RESPONSIVE MOBILE DESIGN */
        /* ============================= */

        @media (max-width: 768px) {
            /* Container & Layout */
            .container {
                padding: 10px;
                max-width: 100%;
            }

            /* Header */
            .header {
                padding: 15px 0;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 28px;
                letter-spacing: 2px;
            }

            .tagline {
                font-size: 12px;
                margin-top: 5px;
            }

            /* Stats Display */
            .stats {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }

            .stat {
                padding: 10px;
                font-size: 14px;
            }

            .stat-value {
                font-size: 18px;
            }

            /* Tabs */
            .tabs {
                flex-wrap: wrap;
                gap: 5px;
                margin-bottom: 15px;
            }

            .tab {
                font-size: 11px;
                padding: 10px 5px;
                min-width: calc(33.333% - 5px);
            }

            /* Buttons */
            .btn {
                padding: 12px 15px;
                font-size: 14px;
                width: 100%;
                margin-bottom: 10px;
            }

            .btn-small {
                padding: 8px 12px;
                font-size: 12px;
            }

            /* Auth Screen */
            .auth-screen {
                padding: 20px 15px;
            }

            .auth-screen h2 {
                font-size: 32px;
                margin-bottom: 15px;
            }

            .form-group {
                margin-bottom: 15px;
            }

            .form-group label {
                font-size: 12px;
            }

            .form-group input {
                padding: 12px;
                font-size: 14px;
            }

            /* Target Grid */
            .targets-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .target-card {
                padding: 12px;
            }

            .target-header {
                font-size: 16px;
                margin-bottom: 8px;
            }

            .target-actions {
                flex-direction: column;
                gap: 8px;
            }

            /* Shop Items */
            .shop-items {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .shop-item {
                padding: 12px;
            }

            /* Upgrades Grid */
            .upgrades-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .upgrade-card {
                padding: 12px;
            }

            /* Defenses */
            .defense-item {
                padding: 10px;
                font-size: 13px;
            }

            /* Activity Log */
            .activity-log {
                max-height: 250px;
            }

            .activity-item {
                padding: 8px;
                font-size: 12px;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                padding: 20px;
                max-height: 90vh;
                overflow-y: auto;
            }

            .modal-content h2 {
                font-size: 22px;
                margin-bottom: 15px;
            }

            /* Attack Modal */
            #attackModalContent .target-info {
                font-size: 13px;
                padding: 10px;
            }

            #attackModalContent .btn {
                margin: 5px 0;
                padding: 10px;
                font-size: 13px;
            }

            /* Operator Panel */
            .operator-panel {
                padding: 15px;
            }

            .operator-header h1 {
                font-size: 28px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .stat-card {
                padding: 15px;
            }

            .users-list {
                max-height: 300px;
            }

            .user-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                padding: 10px;
            }

            .user-info {
                width: 100%;
            }

            /* Section Headers */
            .section h2 {
                font-size: 20px;
            }

            /* Leaderboard */
            .leaderboard-item {
                padding: 10px;
                font-size: 13px;
            }

            /* Earn Button */
            #earnButton {
                width: 100%;
                max-width: 100%;
                height: auto;
                padding: 30px 20px;
                font-size: 20px;
            }

            /* Notifications */
            .notification {
                width: calc(100% - 40px);
                left: 20px;
                right: 20px;
                padding: 12px;
                font-size: 13px;
            }

            /* Confirm/Prompt Modals */
            #confirmModal > div > div,
            #promptModal > div > div {
                max-width: 90%;
                padding: 25px;
            }

            #confirmModal h2,
            #promptModal h2 {
                font-size: 20px;
            }

            #confirmModal p,
            #promptModal p {
                font-size: 14px;
            }

            #promptInput {
                font-size: 16px;
                padding: 12px;
            }

            /* Close Buttons */
            .close-operator {
                font-size: 12px;
                padding: 8px 15px;
            }

            /* Operator Link */
            .operator-link {
                font-size: 11px;
                padding: 8px 15px;
            }
        }

        /* Extra small screens (phones in portrait) */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 24px;
                letter-spacing: 1px;
            }

            .tab {
                font-size: 10px;
                padding: 8px 3px;
            }

            .stat-label {
                font-size: 11px;
            }

            .stat-value {
                font-size: 16px;
            }

            .modal-content {
                padding: 15px;
            }

            .btn {
                font-size: 13px;
                padding: 10px 12px;
            }
        }

        /* Landscape mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .modal-content {
                max-height: 85vh;
            }

            .activity-log {
                max-height: 200px;
            }

            #earnButton {
                padding: 20px 15px;
                font-size: 18px;
            }
        }

        /* Touch improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            .btn {
                min-height: 44px;
            }

            .tab {
                min-height: 44px;
            }

            .target-card,
            .shop-item,
            .upgrade-card {
                min-height: 60px;
            }

            /* Better input on mobile */
            input {
                font-size: 16px !important; /* Prevents iOS zoom */
            }
        }
    </style>
</head>
<body>
    <!-- Auth Screen -->
    <div id="authScreen" class="auth-screen">
        <h2>HACK WARS</h2>
        <p style="text-align: center; opacity: 0.7; margin-bottom: 30px;">Skydda ditt konto. Hacka andra.</p>
        
        <div id="loginForm">
            <div class="form-group">
                <label>Användarnamn</label>
                <input type="text" id="loginUsername" maxlength="20">
            </div>
            <div class="form-group">
                <label>Lösenord (max 8 tecken, bara a-z och 0-9)</label>
                <input type="password" id="loginPassword" maxlength="8">
            </div>
            <button class="btn" onclick="login()">Logga In</button>
            <button class="btn btn-secondary" onclick="showRegister()">Skapa Konto</button>
        </div>

        <div id="registerForm" style="display: none;">
            <div class="form-group">
                <label>Användarnamn</label>
                <input type="text" id="regUsername" maxlength="20">
            </div>
            <div class="form-group">
                <label>Lösenord (max 8 tecken, bara a-z och 0-9)</label>
                <input type="password" id="regPassword" maxlength="8">
                <div class="password-strength" id="passwordStrength"></div>
            </div>
            <button class="btn" onclick="register()">Registrera</button>
            <button class="btn btn-secondary" onclick="showLogin()">Tillbaka till Inloggning</button>
        </div>

        <!-- Operator Access Link -->
        <div class="operator-link" onclick="showOperatorPrompt()">Operator</div>
    </div>

    <!-- Main Game -->
    <div id="gameContainer" class="game-container">
        <div class="container">
            <div class="header">
                <h1>HACK WARS</h1>
                <div class="tagline">
                    Användarnamn: <span id="currentUser"></span>
                    <button class="btn btn-small" onclick="logout()" style="margin-left: 20px; width: auto; padding: 5px 15px; font-size: 12px;">LOGGA UT</button>
                </div>
            </div>

            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-label">Creds</div>
                    <div class="stat-value" id="credsDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Säkerhetspoäng</div>
                    <div class="stat-value" id="securityDisplay">100</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Lyckade Hack</div>
                    <div class="stat-value" id="hacksDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Försvar</div>
                    <div class="stat-value" id="defensesDisplay">0</div>
                </div>
            </div>

            <div class="tabs">
                <div class="tab active" onclick="switchTab('targets')">MÅL</div>
                <div class="tab" onclick="switchTab('shop')">BUTIK</div>
                <div class="tab" onclick="switchTab('defenses')">MITT FÖRSVAR</div>
                <div class="tab" onclick="switchTab('earn')">TJÄNA CREDS</div>
                <div class="tab" onclick="switchTab('leaderboard')">LEADERBOARD</div>
                <div class="tab" onclick="switchTab('activity')">AKTIVITET</div>
            </div>

            <!-- Targets Tab -->
            <div id="targetsTab" class="tab-content active">
                <button class="btn" onclick="scanNetwork()" style="margin-bottom: 20px;">
                    Scanna Nätverk (30 Creds) - Hitta nya mål
                </button>
                <div id="targetsList" class="target-list"></div>
            </div>

            <!-- Shop Tab -->
            <div id="shopTab" class="tab-content">
                <div class="shop-grid" id="shopGrid"></div>
            </div>

            <!-- Defenses Tab -->
            <div id="defensesTab" class="tab-content">
                <h2>Dina Aktiva Försvar</h2>
                <div id="myDefenses" class="defenses-list"></div>
                
                <h2 style="margin-top: 30px;">Ändra Lösenord (500 Creds)</h2>
                <p style="opacity: 0.7; margin-bottom: 15px; font-size: 14px;">
                    Kostar 500 creds. Alla ledtrådar om dig försvinner från andra spelares konton!
                </p>
                <div class="form-group">
                    <label>Nytt Lösenord (max 8 tecken)</label>
                    <input type="password" id="newPassword" maxlength="8">
                </div>
                <button class="btn btn-small" onclick="changePassword()">Byt Lösenord (500 Creds)</button>
            </div>

            <!-- Earn Creds Tab -->
            <div id="earnTab" class="tab-content">
                <h2>Tjäna Creds</h2>
                
                <!-- Current Stats -->
                <div style="border: 2px solid #fff; padding: 20px; margin-bottom: 30px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <div style="opacity: 0.7; font-size: 12px;">CREDS PER KLICK</div>
                            <div id="clickMultiplierDisplay" style="font-size: 24px; font-weight: bold;">1</div>
                        </div>
                        <div>
                            <div style="opacity: 0.7; font-size: 12px;">PASSIV INKOMST</div>
                            <div id="passiveIncomeDisplay" style="font-size: 24px; font-weight: bold; color: #0f0;">0/sek</div>
                        </div>
                    </div>
                </div>
                
                <!-- Click Button -->
                <div style="text-align: center; margin: 30px 0;">
                    <button class="btn" onclick="earnCred()" style="font-size: 24px; padding: 30px 60px;">
                        TJÄNA CREDS
                    </button>
                    <div id="earnCounter" style="margin-top: 20px; font-size: 18px; opacity: 0.7;"></div>
                </div>

                <!-- Upgrades -->
                <h3 style="margin-top: 40px; margin-bottom: 20px;">UPPGRADERINGAR</h3>
                <div id="earnUpgradesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;"></div>
            </div>

            <!-- Leaderboard Tab -->
            <div id="leaderboardTab" class="tab-content">
                <h2>Leaderboard - Rikaste Spelarna</h2>
                <button class="btn btn-small" onclick="loadLeaderboard()" style="margin-bottom: 20px;">Uppdatera Leaderboard</button>
                <div id="leaderboardList" class="target-list"></div>
            </div>

            <!-- Activity Tab -->
            <div id="activityTab" class="tab-content">
                <h2>Aktivitetslogg</h2>
                <div id="activityLog" class="activity-log"></div>
            </div>
        </div>
    </div>

    <!-- Attack Modal -->
    <div id="attackModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeAttackModal()">&times;</span>
            <h2 id="modalTitle">Attackera Mål</h2>
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- Operator Panel -->
    <div id="operatorPanel" class="operator-panel">
        <button class="close-operator" onclick="closeOperatorPanel()">STÄNG</button>
        
        <div class="operator-container">
            <div class="operator-header">
                <h1>OPERATOR PANEL</h1>
                <div class="tagline">ADMINISTRATIV ÅTKOMST</div>
            </div>

            <!-- Stats Overview -->
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="value" id="opTotalUsers">0</div>
                    <div class="label">Totalt Användare</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="opActiveUsers">0</div>
                    <div class="label">Aktiva Användare</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="opHackedUsers">0</div>
                    <div class="label">Hackade Användare</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="opTotalCreds">0</div>
                    <div class="label">Totala Creds</div>
                </div>
            </div>

            <!-- User Management -->
            <div class="section">
                <h2>ANVÄNDARHANTERING</h2>
                <button class="btn btn-operator" onclick="loadAllUsers()" style="margin-bottom: 20px;">Ladda Alla Användare</button>
                <div id="opUsersList"></div>
            </div>

            <!-- Set User Creds -->
            <div class="section">
                <h2>ÄNDRA ANVÄNDARES CREDS</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label>Användarnamn</label>
                        <input type="text" id="setCredsUsername" placeholder="användarnamn" 
                               style="padding: 12px; background: #fff; border: 1px solid #000; color: #000; font-family: 'JetBrains Mono', monospace;">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label>Nya Creds</label>
                        <input type="number" id="setCredsAmount" placeholder="0" min="0"
                               style="padding: 12px; background: #fff; border: 1px solid #000; color: #000; font-family: 'JetBrains Mono', monospace;">
                    </div>
                    <button class="btn btn-operator" onclick="setUserCreds()" style="margin: 0;">
                        SÄTT CREDS
                    </button>
                </div>
                <p style="margin-top: 15px; opacity: 0.7; font-size: 14px;">
                    Skriv användarnamnet och det nya antalet creds. Användarnamn är CASE-SENSITIVE.
                </p>
            </div>

            <!-- Database Operations -->
            <div class="section danger-zone">
                <h2>FARLIGA OPERATIONER</h2>
                <p style="margin-bottom: 20px; opacity: 0.7;">Dessa åtgärder kan inte ångras!</p>
                
                <button class="btn btn-danger" onclick="resetAllPasswords()" style="margin-bottom: 10px;">
                    Återställ Alla Lösenord till "password"
                </button>
                
                <button class="btn btn-danger" onclick="giveAllCreds()" style="margin-bottom: 10px;">
                    Ge Alla Användare 10,000 Creds
                </button>
                
                <button class="btn btn-danger" onclick="cleanupCorruptAccounts()" style="margin-bottom: 10px;">
                    RENSA KORRUPTA KONTON
                </button>
            </div>
            
            <!-- Unban User -->
            <div class="section">
                <h2>UNBANNA ANVÄNDARE</h2>
                <p style="margin-bottom: 15px; opacity: 0.7;">Återställ konto som felaktigt bannats av anti-cheat</p>
                
                <div style="margin-bottom: 10px;">
                    <input type="text" id="unbanUsername" placeholder="Användarnamn" 
                           style="width: 100%; padding: 10px; background: #000; color: #fff; border: 2px solid #fff; font-family: 'JetBrains Mono', monospace;">
                </div>
                
                <button class="btn" onclick="unbanUser()" style="background: #0f0; color: #000; border-color: #0f0;">
                    UNBANNA & ÅTERSTÄLL KONTO
                </button>
            </div>
        </div>
    </div>

    <!-- Operator Password Modal -->
    <div id="operatorPasswordModal" class="operator-password-modal">
        <div class="operator-password-content">
            <h2>OPERATOR ACCESS</h2>
            <input type="password" id="operatorPasswordInput" placeholder="******" maxlength="20" 
                   autocomplete="new-password" data-form-type="other">
            <div class="operator-password-buttons">
                <button class="btn btn-operator" onclick="checkOperatorPassword()">OK</button>
                <button class="btn btn-secondary" onclick="closeOperatorPasswordModal()">AVBRYT</button>
            </div>
        </div>
    </div>

    <!-- Critical Message Modal (replaces browser alerts) -->
    <div id="criticalModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000;">
        <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
            <div style="background: #000; border: 4px solid #f00; padding: 40px; max-width: 600px; text-align: center;">
                <h2 id="criticalTitle" style="color: #f00; font-size: 32px; margin-bottom: 20px; text-transform: uppercase;"></h2>
                <p id="criticalMessage" style="font-size: 18px; line-height: 1.6; margin-bottom: 30px; white-space: pre-line;"></p>
                <button class="btn" onclick="handleCriticalClose()" style="background: #f00; color: #fff; border-color: #f00;">OK - LADDA OM</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal (replaces browser confirms) -->
    <div id="confirmModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000;">
        <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
            <div style="background: #fff; border: 4px solid #000; padding: 40px; max-width: 600px; text-align: center;">
                <h2 id="confirmTitle" style="color: #000; font-size: 24px; margin-bottom: 20px; text-transform: uppercase;">BEKRÄFTA</h2>
                <p id="confirmMessage" style="font-size: 18px; line-height: 1.6; margin-bottom: 30px; color: #000;"></p>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button class="btn" onclick="handleConfirmYes()" style="background: #000; color: #fff; border-color: #000;">JA</button>
                    <button class="btn" onclick="handleConfirmNo()" style="background: #fff; color: #000; border-color: #000;">NEJ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Prompt Modal (replaces browser prompts) -->
    <div id="promptModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000;">
        <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
            <div style="background: #000; border: 4px solid #fff; padding: 40px; max-width: 600px; text-align: center; min-width: 400px;">
                <h2 id="promptTitle" style="color: #fff; font-size: 24px; margin-bottom: 20px; text-transform: uppercase;">ANGE SVAR</h2>
                <p id="promptMessage" style="font-size: 18px; line-height: 1.6; margin-bottom: 20px; color: #fff;"></p>
                <input type="text" id="promptInput" style="width: 100%; padding: 15px; background: #000; color: #fff; border: 2px solid #fff; font-family: 'JetBrains Mono', monospace; font-size: 18px; margin-bottom: 20px; text-align: center;">
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button class="btn" onclick="handlePromptSubmit()" style="background: #fff; color: #000; border-color: #fff;">OK</button>
                    <button class="btn" onclick="handlePromptCancel()" style="background: #000; color: #fff; border-color: #fff;">AVBRYT</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update, onValue, push, query, orderByChild, limitToLast } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDFRQp1Q9XDMjyJh-y8VnTWjQUQSC9j-jQ",
            authDomain: "hack-wars-c2d47.firebaseapp.com",
            databaseURL: "https://hack-wars-c2d47-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "hack-wars-c2d47",
            storageBucket: "hack-wars-c2d47.firebasestorage.app",
            messagingSenderId: "440274065986",
            appId: "1:440274065986:web:ea555b913c3f701aba2bdb"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        window.db = db;
        window.dbRef = ref;
        window.dbSet = set;
        window.dbGet = get;
        window.dbUpdate = update;
        window.dbOnValue = onValue;
        window.dbPush = push;

        let currentUsername = null;
        let userData = null;
        let scannedTargets = [];
        let earnClicks = 0;
        let shopUpdateTimer = null;
        let defensesUpdateTimer = null;
        let passiveIncomeTimer = null;
        let realtimeUnsubscribe = null;
        
        // System configuration constants
        const _0xa1f3 = 'b3BlcmF0b3I=';
        const _0xb8e2 = 'cGFzc3dvcmQ=';
        const _0xc3d1 = 'YWRtaW5pc3RyYXRvcg==';
        const _0xd9f4 = 'dmVyNnQzMjAxMg==';
        const _0xe7a2 = 'c3VwZXJ1c2Vy';

        // ANTI-CHEAT SYSTEM
        const ANTI_CHEAT = {
            credGains: [],
            rapidActions: [],
            
            logCredGain(amount, source = 'click') {
                const now = Date.now();
                this.credGains.push({ amount, timestamp: now, source });
                
                // Keep only last minute of data
                this.credGains = this.credGains.filter(g => now - g.timestamp < 60000);
            },
            
            logAction(actionType) {
                const now = Date.now();
                this.rapidActions.push({ action: actionType, timestamp: now });
                
                // Keep only last second of data
                this.rapidActions = this.rapidActions.filter(a => now - a.timestamp < 1000);
            },
            
            checkSuspiciousActivity() {
                const now = Date.now();
                
                // EXCLUDE legitimate hack gains from anti-cheat checks
                const clickGainsOnly = this.credGains.filter(g => g.source === 'click');
                const passiveGainsOnly = this.credGains.filter(g => g.source === 'passive');
                
                // Check for instant massive gains from CLICKING (1M+ creds in single click)
                const recentClickGain = clickGainsOnly[clickGainsOnly.length - 1];
                if (recentClickGain && recentClickGain.amount >= 1000000) {
                    this.triggerBan('Instant massive cred gain from clicking detected');
                    return true;
                }
                
                // Check per-second CLICK rate (max 1000 creds/sec from clicking)
                const lastSecondClicks = clickGainsOnly.filter(g => now - g.timestamp < 1000);
                const lastSecondClickTotal = lastSecondClicks.reduce((sum, g) => sum + g.amount, 0);
                if (lastSecondClickTotal > 1000) {
                    this.triggerBan('Click earning rate too high (>1000 creds/sec)');
                    return true;
                }
                
                // Check per-minute CLICK+PASSIVE rate (max 50,000 creds/min)
                // HACK gains are NOT included here!
                const totalLastMinuteNonHack = [...clickGainsOnly, ...passiveGainsOnly].reduce((sum, g) => sum + g.amount, 0);
                if (totalLastMinuteNonHack > 50000) {
                    this.triggerBan('Earning rate too high (>50k creds/min from non-hack sources)');
                    return true;
                }
                
                // Check rapid action spam (max 20 actions/sec)
                if (this.rapidActions.length > 20) {
                    this.triggerBan('Action spam detected (>20 actions/sec)');
                    return true;
                }
                
                return false;
            },
            
            async triggerBan(reason) {
                console.error('ANTI-CHEAT BAN:', reason);
                
                const userRef = ref(db, `users/${currentUsername}`);
                await update(userRef, {
                    hacked: true,
                    banned: true,
                    banReason: reason,
                    bannedAt: Date.now()
                });
                
                await addActivityLog(currentUsername, `BANNAD: ${reason}`);
                
                showCriticalMessage(
                    'ANTI-CHEAT BAN',
                    `Du har blivit bannad för fusk!\n\nAnledning: ${reason}\n\nDitt konto har raderats.`
                );
                
                await set(userRef, null);
                localStorage.removeItem('hackwars_username');
            }
        };

        // Critical message system (replaces browser alerts)
        let criticalAction = null;
        
        function showCriticalMessage(title, message, action = 'reload') {
            document.getElementById('criticalTitle').textContent = title;
            document.getElementById('criticalMessage').textContent = message;
            document.getElementById('criticalModal').style.display = 'block';
            criticalAction = action;
            
            // Update button text
            const btn = document.querySelector('#criticalModal button');
            if (action === 'reload') {
                btn.textContent = 'OK - LADDA OM';
            } else {
                btn.textContent = 'OK';
            }
        }
        
        window.handleCriticalClose = function() {
            document.getElementById('criticalModal').style.display = 'none';
            if (criticalAction === 'reload') {
                window.location.reload();
            }
            // If 'none', just close the modal
        };

        // Confirmation system (replaces browser confirms)
        let confirmCallback = null;
        
        function showConfirm(message, onYes, onNo = null, isOperator = false) {
            const modal = document.getElementById('confirmModal');
            const title = document.getElementById('confirmTitle');
            const msg = document.getElementById('confirmMessage');
            
            // Set message text
            title.textContent = 'BEKRÄFTA';
            msg.textContent = message;
            
            // Get the actual modal box (third div)
            const modalBox = modal.children[0].children[0];
            const buttons = modalBox.querySelectorAll('button');
            
            if (isOperator) {
                // Operator panel: BLACK background, WHITE text
                modalBox.setAttribute('style', 'background: #000 !important; border: 4px solid #fff !important; padding: 40px; max-width: 600px; text-align: center;');
                title.setAttribute('style', 'color: #fff !important; font-size: 24px; margin-bottom: 20px; text-transform: uppercase;');
                msg.setAttribute('style', 'font-size: 18px; line-height: 1.6; margin-bottom: 30px; color: #fff !important;');
                buttons[0].setAttribute('style', 'background: #fff !important; color: #000 !important; border-color: #fff !important;');
                buttons[1].setAttribute('style', 'background: #000 !important; color: #fff !important; border-color: #fff !important;');
            } else {
                // Normal: WHITE background, BLACK text
                modalBox.setAttribute('style', 'background: #fff !important; border: 4px solid #000 !important; padding: 40px; max-width: 600px; text-align: center;');
                title.setAttribute('style', 'color: #000 !important; font-size: 24px; margin-bottom: 20px; text-transform: uppercase;');
                msg.setAttribute('style', 'font-size: 18px; line-height: 1.6; margin-bottom: 30px; color: #000 !important;');
                buttons[0].setAttribute('style', 'background: #000 !important; color: #fff !important; border-color: #000 !important;');
                buttons[1].setAttribute('style', 'background: #fff !important; color: #000 !important; border-color: #000 !important;');
            }
            
            modal.style.display = 'block';
            confirmCallback = { onYes, onNo };
        }
        
        window.handleConfirmYes = function() {
            document.getElementById('confirmModal').style.display = 'none';
            if (confirmCallback && confirmCallback.onYes) {
                confirmCallback.onYes();
            }
            confirmCallback = null;
        };
        
        window.handleConfirmNo = function() {
            document.getElementById('confirmModal').style.display = 'none';
            if (confirmCallback && confirmCallback.onNo) {
                confirmCallback.onNo();
            }
            confirmCallback = null;
        };

        // Prompt system (replaces browser prompts)
        let promptCallback = null;
        
        function showPrompt(message, onSubmit, onCancel = null) {
            document.getElementById('promptMessage').textContent = message;
            document.getElementById('promptInput').value = '';
            document.getElementById('promptModal').style.display = 'block';
            promptCallback = { onSubmit, onCancel };
            
            // Focus input
            setTimeout(() => document.getElementById('promptInput').focus(), 100);
            
            // Allow Enter key to submit
            const input = document.getElementById('promptInput');
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    handlePromptSubmit();
                }
            };
        }
        
        window.handlePromptSubmit = function() {
            const value = document.getElementById('promptInput').value;
            document.getElementById('promptModal').style.display = 'none';
            if (promptCallback && promptCallback.onSubmit) {
                promptCallback.onSubmit(value);
            }
            promptCallback = null;
        };
        
        window.handlePromptCancel = function() {
            document.getElementById('promptModal').style.display = 'none';
            if (promptCallback && promptCallback.onCancel) {
                promptCallback.onCancel();
            }
            promptCallback = null;
        };

        // Check if user is already logged in
        window.addEventListener('DOMContentLoaded', function() {
            const savedUsername = localStorage.getItem('hackwars_username');
            if (savedUsername) {
                autoLogin(savedUsername);
            }
        });

        async function autoLogin(username) {
            const userRef = ref(db, `users/${username}`);
            const snapshot = await get(userRef);

            if (!snapshot.exists()) {
                // User was deleted, clear localStorage
                localStorage.removeItem('hackwars_username');
                return;
            }

            const user = snapshot.val();

            // Check if account has been hacked
            if (user.hacked) {
                showCriticalMessage(
                    'KONTO HACKAT',
                    'DITT KONTO HAR BLIVIT HACKAT OCH RADERAT!\n\nDu måste skapa ett nytt konto för att fortsätta spela.'
                );
                
                // Delete the hacked account
                await set(userRef, null);
                localStorage.removeItem('hackwars_username');
                return;
            }

            currentUsername = username;
            userData = user;

            // Give daily login bonus
            await update(userRef, {
                lastLogin: Date.now()
            });

            startGame();
        }

        // Format numbers with K, M, B suffixes
        function formatNumber(num) {
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            }
            return num.toString();
        }

        // Helper to get click multiplier from upgrades
        function getClickMultiplier() {
            const upgrades = userData.earnUpgrades || [];
            let maxMultiplier = 1;
            
            upgrades.forEach(upgradeId => {
                const upgrade = earnUpgrades.find(u => u.id === upgradeId && u.type === 'click');
                if (upgrade && upgrade.multiplier > maxMultiplier) {
                    maxMultiplier = upgrade.multiplier;
                }
            });
            
            return maxMultiplier;
        }

        // Helper to get passive income per second
        function getPassiveIncome() {
            const upgrades = userData.earnUpgrades || [];
            let totalPassive = 0;
            
            upgrades.forEach(upgradeId => {
                const upgrade = earnUpgrades.find(u => u.id === upgradeId && u.type === 'passive');
                if (upgrade) {
                    totalPassive += upgrade.passive;
                }
            });
            
            return totalPassive;
        }

        window.earnCred = async function() {
            const multiplier = getClickMultiplier();
            const amount = 1 * multiplier;
            
            // ANTI-CHEAT: Log this cred gain as CLICK source
            ANTI_CHEAT.logCredGain(amount, 'click');
            ANTI_CHEAT.logAction('earn_click');
            
            if (ANTI_CHEAT.checkSuspiciousActivity()) {
                return; // Banned!
            }
            
            earnClicks += amount;
            
            // CRITICAL: Read current creds from Firebase first!
            const userRef = ref(db, `users/${currentUsername}`);
            const snapshot = await get(userRef);
            if (!snapshot.exists()) return;
            
            const currentCreds = snapshot.val().creds || 0;
            
            await update(userRef, {
                creds: currentCreds + amount
            });

            document.getElementById('earnCounter').textContent = `Du har tjänat ${earnClicks} creds genom att klicka!`;
            showNotification(`+${amount} Cred${amount > 1 ? 's' : ''}!`);
        };

        // Load and display earn upgrades
        function loadEarnUpgrades() {
            const upgradesGrid = document.getElementById('earnUpgradesGrid');
            const owned = userData.earnUpgrades || [];
            
            upgradesGrid.innerHTML = earnUpgrades.map(upgrade => {
                const isOwned = owned.includes(upgrade.id);
                const canBuy = !isOwned && userData.creds >= upgrade.cost;
                const requiresMet = !upgrade.requires || owned.includes(upgrade.requires);
                const isLocked = !requiresMet;
                
                let statusText = '';
                if (isOwned) {
                    statusText = '<span style="color: #0f0;">ÄGER</span>';
                } else if (isLocked) {
                    const requiredUpgrade = earnUpgrades.find(u => u.id === upgrade.requires);
                    statusText = `<span style="color: #f00;">LÅST - Kräver: ${requiredUpgrade.name}</span>`;
                } else {
                    statusText = canBuy ? '' : '<span style="color: #f00;">Inte tillräckligt med creds</span>';
                }
                
                return `
                    <div class="shop-item ${isOwned ? 'owned' : ''}">
                        <h3>${upgrade.name}</h3>
                        <div class="description">${upgrade.description}</div>
                        <div class="price">${formatNumber(upgrade.cost)} CREDS</div>
                        ${statusText ? `<div style="margin-bottom: 10px;">${statusText}</div>` : ''}
                        <button class="btn btn-small" 
                                onclick="buyEarnUpgrade('${upgrade.id}')" 
                                ${isOwned || isLocked ? 'disabled' : ''}>
                            ${isOwned ? 'ÄGER' : isLocked ? 'LÅST' : 'KÖP'}
                        </button>
                    </div>
                `;
            }).join('');
            
            // Update displays
            document.getElementById('clickMultiplierDisplay').textContent = getClickMultiplier();
            document.getElementById('passiveIncomeDisplay').textContent = getPassiveIncome() + '/sek';
        }

        // Buy an earn upgrade
        window.buyEarnUpgrade = async function(upgradeId) {
            const upgrade = earnUpgrades.find(u => u.id === upgradeId);
            if (!upgrade) return;
            
            const owned = userData.earnUpgrades || [];
            
            if (owned.includes(upgradeId)) {
                showNotification('Du äger redan denna uppgradering!', true);
                return;
            }
            
            if (upgrade.requires && !owned.includes(upgrade.requires)) {
                showNotification('Du måste köpa föregående uppgradering först!', true);
                return;
            }
            
            // CRITICAL: Read current creds from Firebase
            const userRef = ref(db, `users/${currentUsername}`);
            const snapshot = await get(userRef);
            if (!snapshot.exists()) return;
            
            const currentCreds = snapshot.val().creds || 0;
            
            if (currentCreds < upgrade.cost) {
                showNotification('Inte tillräckligt med creds!', true);
                return;
            }
            
            const newUpgrades = [...owned, upgradeId];
            await update(userRef, {
                earnUpgrades: newUpgrades,
                creds: currentCreds - upgrade.cost
            });
            
            showNotification(`Köpte ${upgrade.name}!`);
            loadEarnUpgrades();
        };

        // Start passive income loop
        function startPassiveIncome() {
            // Clear any existing timer first
            if (passiveIncomeTimer) {
                clearInterval(passiveIncomeTimer);
            }
            
            passiveIncomeTimer = setInterval(async () => {
                if (!currentUsername || !userData) return;
                
                const passive = getPassiveIncome();
                if (passive > 0) {
                    // ANTI-CHEAT: Log passive income as PASSIVE source
                    ANTI_CHEAT.logCredGain(passive, 'passive');
                    
                    const userRef = ref(db, `users/${currentUsername}`);
                    
                    // CRITICAL: Read current creds from Firebase first!
                    const snapshot = await get(userRef);
                    if (!snapshot.exists()) return;
                    
                    const currentCreds = snapshot.val().creds || 0;
                    
                    await update(userRef, {
                        creds: currentCreds + passive
                    });
                }
            }, 1000); // Every second
        }

        window.logout = function() {
            showConfirm('Är du säker på att du vill logga ut?', function() {
                // Yes - logout
                // Clear all timers and listeners
                if (passiveIncomeTimer) clearInterval(passiveIncomeTimer);
                if (shopUpdateTimer) clearTimeout(shopUpdateTimer);
                if (defensesUpdateTimer) clearTimeout(defensesUpdateTimer);
                if (realtimeUnsubscribe) realtimeUnsubscribe();
                
                localStorage.removeItem('hackwars_username');
                window.location.reload();
            });
        };

        window.loadLeaderboard = async function() {
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '<div class="loading">Laddar leaderboard...</div>';

            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            if (!snapshot.exists()) {
                leaderboardList.innerHTML = '<div class="empty-state">Inga användare hittades!</div>';
                return;
            }

            const allUsers = [];
            snapshot.forEach(childSnapshot => {
                const user = childSnapshot.val();
                // Only add valid users with username
                if (user && user.username) {
                    allUsers.push(user);
                }
            });

            // Sort by creds descending
            allUsers.sort((a, b) => (b.creds || 0) - (a.creds || 0));

            // Take top 10
            const top10 = allUsers.slice(0, 10);

            leaderboardList.innerHTML = '';
            top10.forEach((user, index) => {
                const card = document.createElement('div');
                card.className = 'target-card';
                card.style.background = user.username === currentUsername ? '#111' : '#000';
                
                card.innerHTML = `
                    <div class="target-info">
                        <h3>#${index + 1} ${user.username}${user.username === currentUsername ? ' (DIG)' : ''}</h3>
                        <div class="target-detail">Creds: ${formatNumber(user.creds || 0)}</div>
                        <div class="target-detail">Lyckade Hack: ${user.successfulHacks || 0}</div>
                    </div>
                `;
                leaderboardList.appendChild(card);
            });
        };

        const shopItems = [
            { id: '2fa', name: '2FA Simulator', cost: 100, description: '30% chans att blockera hack-försök' },
            { id: 'vpn', name: 'VPN', cost: 80, description: '50% chans att döljas vid scanning' },
            { id: 'honeypot', name: 'Honeypot', cost: 120, description: 'Trackar vem som försöker hacka dig' },
            { id: 'decoy', name: 'Decoy System', cost: 250, description: '50% av ledtrådar blir falska' },
            { id: 'alert', name: 'Alert System', cost: 100, description: 'Få notis när någon samlar ledtrådar' },
            { id: 'counter', name: 'Counter-Hack', cost: 300, description: 'Stjäl upp till 20 creds från misslyckade hacks' }
        ];

        // UPGRADE SYSTEM for earning creds
        const earnUpgrades = [
            { 
                id: 'click2x', 
                name: 'Dubbel-Klick', 
                description: 'Få 2 creds per klick istället för 1', 
                cost: 500,
                multiplier: 2,
                type: 'click'
            },
            { 
                id: 'click5x', 
                name: 'Mega-Klick', 
                description: 'Få 5 creds per klick', 
                cost: 2000,
                multiplier: 5,
                type: 'click',
                requires: 'click2x'
            },
            { 
                id: 'click10x', 
                name: 'Ultra-Klick', 
                description: 'Få 10 creds per klick', 
                cost: 5000,
                multiplier: 10,
                type: 'click',
                requires: 'click5x'
            },
            { 
                id: 'passive1', 
                name: 'Bot-Farm Nivå 1', 
                description: '+1 cred/sek (automatiskt)', 
                cost: 1000,
                passive: 1,
                type: 'passive'
            },
            { 
                id: 'passive5', 
                name: 'Bot-Farm Nivå 2', 
                description: '+5 creds/sek (automatiskt)', 
                cost: 5000,
                passive: 5,
                type: 'passive',
                requires: 'passive1'
            },
            { 
                id: 'passive10', 
                name: 'Bot-Farm Nivå 3', 
                description: '+10 creds/sek (automatiskt)', 
                cost: 15000,
                passive: 10,
                type: 'passive',
                requires: 'passive5'
            },
            { 
                id: 'passive50', 
                name: 'Server-Farm', 
                description: '+50 creds/sek (automatiskt)', 
                cost: 50000,
                passive: 50,
                type: 'passive',
                requires: 'passive10'
            }
        ];

        window.showRegister = function() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
        };

        window.showLogin = function() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
        };

        document.getElementById('regPassword')?.addEventListener('input', function(e) {
            const password = e.target.value;
            const valid = /^[a-z0-9]*$/i.test(password);
            const strength = document.getElementById('passwordStrength');
            
            if (!valid && password.length > 0) {
                strength.textContent = 'Bara a-z och 0-9 tillåtna!';
                strength.style.color = '#f00';
            } else if (password.length > 0) {
                strength.textContent = `Giltigt lösenord (${password.length}/8 tecken)`;
                strength.style.color = '#0f0';
            } else {
                strength.textContent = '';
            }
        });

        window.register = async function() {
            const username = document.getElementById('regUsername').value.trim();
            const password = document.getElementById('regPassword').value.trim();

            if (!username || !password) {
                showNotification('Fyll i alla fält!', true);
                return;
            }

            if (username === 'undefined' || password === 'undefined') {
                showNotification('Ogiltigt användarnamn eller lösenord!', true);
                return;
            }

            if (password.length > 8) {
                showNotification('Lösenord får max vara 8 tecken!', true);
                return;
            }

            if (!/^[a-z0-9]+$/i.test(password)) {
                showNotification('Lösenord får bara innehålla a-z och 0-9!', true);
                return;
            }

            if (!/^[a-z0-9]+$/i.test(username)) {
                showNotification('Användarnamn får bara innehålla a-z och 0-9!', true);
                return;
            }

            try {
                const userRef = ref(db, `users/${username}`);
                const snapshot = await get(userRef);

                if (snapshot.exists()) {
                    showNotification('Användarnamn redan taget!', true);
                    return;
                }

                const newUser = {
                    username: username,
                    password: password,
                    creds: 100,
                    security: 100,
                    successfulHacks: 0,
                    defenses: [],
                    earnUpgrades: [],
                    failedHackAttempts: {},
                    clues: {},
                    lastLogin: Date.now(),
                    createdAt: Date.now(),
                    activityLog: []
                };

                await set(userRef, newUser);
                
                // Save to localStorage for auto-login
                localStorage.setItem('hackwars_username', username);
                
                showNotification('Konto skapat! Logga in nu.');
                showLogin();
            } catch (error) {
                showNotification('Fel: ' + error.message, true);
            }
        };

        window.login = async function() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value.trim();

            if (!username || !password) {
                showNotification('Fyll i alla fält!', true);
                return;
            }

            try {
                const userRef = ref(db, `users/${username}`);
                const snapshot = await get(userRef);

                if (!snapshot.exists()) {
                    showNotification('Användarnamn finns inte!', true);
                    return;
                }

                const user = snapshot.val();

                // Check if account has been hacked
                if (user.hacked) {
                    showCriticalMessage(
                        'KONTO HACKAT',
                        'DITT KONTO HAR BLIVIT HACKAT OCH RADERAT!\n\nDu måste skapa ett nytt konto för att försätta spela.'
                    );
                    
                    // Delete the hacked account
                    await set(userRef, null);
                    return;
                }

                if (user.password !== password) {
                    showNotification('Fel lösenord!', true);
                    return;
                }

                currentUsername = username;
                userData = user;

                // Save to localStorage for auto-login
                localStorage.setItem('hackwars_username', username);

                // Check if user should get daily login bonus (once per 24 hours)
                const now = Date.now();
                const lastLogin = user.lastLogin || 0;
                const dayInMs = 24 * 60 * 60 * 1000;
                const shouldGetBonus = (now - lastLogin) >= dayInMs;

                if (shouldGetBonus) {
                    // Give daily login bonus
                    await update(userRef, {
                        lastLogin: now,
                        creds: (user.creds || 0) + 20
                    });
                    addActivityLog(username, 'Loggade in och fick 20 creds (daglig bonus)');
                    showNotification('Välkommen tillbaka, ' + username + '! +20 creds daglig bonus');
                } else {
                    // Just update last login time, no bonus
                    await update(userRef, {
                        lastLogin: now
                    });
                    showNotification('Välkommen tillbaka, ' + username + '!');
                }
                
                startGame();
            } catch (error) {
                showNotification('Fel: ' + error.message, true);
            }
        };

        function startGame() {
            document.getElementById('authScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            document.getElementById('currentUser').textContent = currentUsername;

            loadUserData();
            loadShop();
            loadEarnUpgrades();
            setupRealtimeUpdates();
            startPassiveIncome();
        }

        function setupRealtimeUpdates() {
            const userRef = ref(db, `users/${currentUsername}`);
            
            // Store unsubscribe function to clean up later
            realtimeUnsubscribe = onValue(userRef, (snapshot) => {
                if (snapshot.exists()) {
                    userData = snapshot.val();
                    
                    // Check if account was hacked
                    if (userData.hacked) {
                        showCriticalMessage(
                            'KONTO HACKAT',
                            'DITT KONTO HAR BLIVIT HACKAT OCH RADERAT!\n\nDu måste skapa ett nytt konto för att fortsätta spela.'
                        );
                        
                        // Delete the hacked account
                        set(userRef, null);
                        localStorage.removeItem('hackwars_username');
                        return;
                    }
                    
                    updateUI();
                } else {
                    // Account was deleted by admin
                    showCriticalMessage(
                        'KONTO RADERAT',
                        'DITT KONTO HAR RADERATS!\n\nDu måste skapa ett nytt konto.'
                    );
                    localStorage.removeItem('hackwars_username');
                }
            });
        }

        function updateUI() {
            document.getElementById('credsDisplay').textContent = formatNumber(userData.creds || 0);
            document.getElementById('securityDisplay').textContent = userData.security || 100;
            document.getElementById('hacksDisplay').textContent = userData.successfulHacks || 0;
            document.getElementById('defensesDisplay').textContent = getActiveDefenses(userData.defenses || []).length;

            updateMyDefenses();
            updateActivityLog();
        }

        async function loadUserData() {
            const userRef = ref(db, `users/${currentUsername}`);
            const snapshot = await get(userRef);
            if (snapshot.exists()) {
                userData = snapshot.val();
                updateUI();
            }
        }

        function loadShop() {
            const shopGrid = document.getElementById('shopGrid');
            shopGrid.innerHTML = '';

            let userDefenses = userData.defenses || [];
            
            // Migrate old format to new format
            userDefenses = userDefenses.map(d => {
                if (typeof d === 'string') {
                    return { id: d, activatedAt: 0, expiresAt: 0 };
                }
                return d;
            });

            const activeDefenses = getActiveDefenses(userDefenses);

            shopItems.forEach(item => {
                const isActive = activeDefenses.includes(item.id);
                const defense = userDefenses.find(d => d.id === item.id);
                
                let timeLeft = '';
                if (defense && defense.expiresAt > Date.now()) {
                    const seconds = Math.floor((defense.expiresAt - Date.now()) / 1000);
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    timeLeft = `${mins}:${secs.toString().padStart(2, '0')} kvar`;
                }

                const div = document.createElement('div');
                div.className = 'shop-item' + (isActive ? ' owned' : '');
                div.innerHTML = `
                    <h3>${item.name}</h3>
                    <div class="description">${item.description}</div>
                    <div class="price">${formatNumber(item.cost)} CREDS</div>
                    ${isActive ? 
                        `<div style="color: #0f0; margin: 10px 0; font-size: 14px;">AKTIVT: ${timeLeft}</div>
                         <button class="btn btn-small" disabled>AKTIVT</button>` :
                        `<button class="btn btn-small" onclick="buyItem('${item.id}')">KÖP (3 MIN)</button>`
                    }
                `;
                shopGrid.appendChild(div);
            });

            // Clear previous timer
            if (shopUpdateTimer) {
                clearTimeout(shopUpdateTimer);
            }
            
            // Only continue updating if shop tab is active
            const shopTab = document.getElementById('shopTab');
            if (shopTab && shopTab.classList.contains('active')) {
                shopUpdateTimer = setTimeout(loadShop, 1000);
            }
        }

        window.buyItem = async function(itemId) {
            const item = shopItems.find(i => i.id === itemId);
            if (!item) return;

            // CRITICAL: Read current data from Firebase first
            const userRef = ref(db, `users/${currentUsername}`);
            const snapshot = await get(userRef);
            if (!snapshot.exists()) return;
            
            const currentData = snapshot.val();
            const currentCreds = currentData.creds || 0;

            if (currentCreds < item.cost) {
                showNotification('Inte tillräckligt med creds!', true);
                return;
            }

            // Get current defenses and migrate old format
            let defenses = currentData.defenses || [];
            defenses = defenses.map(d => {
                if (typeof d === 'string') {
                    return { id: d, activatedAt: 0, expiresAt: 0 };
                }
                return d;
            });
            
            // Clean up expired defenses
            const now = Date.now();
            defenses = defenses.filter(d => d.expiresAt > now);

            // Check if defense is already active (not expired)
            const activeDefenses = getActiveDefenses(defenses);
            if (activeDefenses.includes(itemId)) {
                showNotification('Detta försvar är redan aktivt!', true);
                return;
            }

            // Add new defense with timestamp (expires in 3 minutes)
            const newDefense = {
                id: itemId,
                activatedAt: Date.now(),
                expiresAt: Date.now() + (3 * 60 * 1000) // 3 minutes
            };
            
            const newDefenses = [...defenses, newDefense];
            const newCreds = currentCreds - item.cost;

            await update(userRef, {
                defenses: newDefenses,
                creds: newCreds
            });

            addActivityLog(currentUsername, `Köpte ${item.name} för ${formatNumber(item.cost)} creds (aktiv i 3 minuter)`);
            showNotification(`Köpte ${item.name}! Aktivt i 3 minuter.`);
            loadShop();
        };

        // Helper function to get currently active defenses
        function getActiveDefenses(defenses) {
            if (!defenses || defenses.length === 0) return [];
            
            // Migrate old format (strings) to new format (objects with timestamps)
            defenses = defenses.map(d => {
                if (typeof d === 'string') {
                    // Old format - treat as expired (force re-purchase)
                    return { id: d, activatedAt: 0, expiresAt: 0 };
                }
                return d;
            });
            
            const now = Date.now();
            return defenses
                .filter(d => d.expiresAt > now)
                .map(d => d.id);
        }

        // Helper function to check if user has active defense
        function hasActiveDefense(defenses, defenseId) {
            if (!defenses || defenses.length === 0) return false;
            
            // Migrate old format
            defenses = defenses.map(d => {
                if (typeof d === 'string') {
                    return { id: d, activatedAt: 0, expiresAt: 0 };
                }
                return d;
            });
            
            const now = Date.now();
            return defenses.some(d => d.id === defenseId && d.expiresAt > now);
        }

        window.scanNetwork = async function() {
            // CRITICAL: Read current creds from Firebase first
            const userRef = ref(db, `users/${currentUsername}`);
            const userSnapshot = await get(userRef);
            if (!userSnapshot.exists()) return;
            
            const currentCreds = userSnapshot.val().creds || 0;
            
            if (currentCreds < 30) {
                showNotification('Inte tillräckligt med creds!', true);
                return;
            }

            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);
            
            if (!snapshot.exists()) {
                showNotification('Inga användare hittades!', true);
                return;
            }

            const allUsers = [];
            snapshot.forEach(childSnapshot => {
                const user = childSnapshot.val();
                // Only add valid users with username
                if (user && user.username && user.username !== currentUsername) {
                    allUsers.push(user);
                }
            });

            if (allUsers.length === 0) {
                showNotification('Inga andra användare finns än!', true);
                return;
            }

            // Randomly select 3 users
            const shuffled = allUsers.sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, 3);

            scannedTargets = selected;

            // Deduct cost
            await update(userRef, {
                creds: currentCreds - 30
            });

            addActivityLog(currentUsername, 'Scannade nätverket för 30 creds');
            displayTargets();
            showNotification('Hittade ' + selected.length + ' mål!');
        };

        function displayTargets() {
            const targetsList = document.getElementById('targetsList');
            
            if (scannedTargets.length === 0) {
                targetsList.innerHTML = '<div class="empty-state">Scanna nätverket för att hitta mål!</div>';
                return;
            }

            targetsList.innerHTML = '';

            scannedTargets.forEach(target => {
                const activeDefenses = getActiveDefenses(target.defenses || []);
                const hasVPN = activeDefenses.includes('vpn');
                
                if (hasVPN && Math.random() < 0.5) {
                    // VPN hides user 50% of the time
                    return;
                }

                const card = document.createElement('div');
                card.className = 'target-card';
                
                const timeSince = Math.floor((Date.now() - (target.lastLogin || 0)) / 60000);
                const timeStr = timeSince < 60 ? timeSince + ' min sedan' : Math.floor(timeSince / 60) + ' timmar sedan';

                card.innerHTML = `
                    <div class="target-info">
                        <h3>${target.username}</h3>
                        <div class="target-detail">Senast inloggad: ${timeStr}</div>
                        <div class="target-detail">Försvar: ${getActiveDefenses(target.defenses || []).length}</div>
                        <div class="target-detail">Säkerhetspoäng: ${target.security || 100}</div>
                    </div>
                    <div class="target-actions">
                        <button class="btn btn-small" onclick="attemptHack('${target.username}')">Försök Hacka</button>
                        <button class="btn btn-small" onclick="gatherClues('${target.username}')">Samla Ledtrådar</button>
                    </div>
                `;
                targetsList.appendChild(card);
            });
        }

        window.attemptHack = function(targetUsername) {
            const modal = document.getElementById('attackModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');

            modalTitle.textContent = `Hacka ${targetUsername}`;
            
            const clues = userData.clues?.[targetUsername] || [];
            
            modalContent.innerHTML = `
                <h3>Dina Ledtrådar:</h3>
                ${clues.length === 0 ? 
                    '<p style="opacity: 0.5;">Inga ledtrådar samlade än!</p>' :
                    '<div class="clues-container">' + 
                    clues.map(c => `<div class="clue-item">${c}</div>`).join('') + 
                    '</div>'
                }
                
                <h3 style="margin-top: 30px;">Gissa Lösenord:</h3>
                <div class="form-group">
                    <input type="text" id="guessPassword" maxlength="8" placeholder="Ange lösenord...">
                </div>
                <button class="btn" onclick="submitHackAttempt('${targetUsername}')">FÖRSÖK HACKA</button>
                
                <p style="margin-top: 20px; font-size: 12px; opacity: 0.7;">
                    Varning: Felaktiga försök ökar larm-nivån. Vid 5 fel låses kontot i 24h för dig.
                </p>
            `;

            modal.classList.add('active');
        };

        window.submitHackAttempt = async function(targetUsername) {
            const guess = document.getElementById('guessPassword').value.trim();

            if (!guess) {
                showNotification('Ange ett lösenord!', true);
                return;
            }

            const targetRef = ref(db, `users/${targetUsername}`);
            const targetSnapshot = await get(targetRef);

            if (!targetSnapshot.exists()) {
                showNotification('Användare finns inte längre!', true);
                closeAttackModal();
                return;
            }

            const target = targetSnapshot.val();
            
            // Check for lockout (5 failed attempts = 24h lockout)
            const userRef = ref(db, `users/${currentUsername}`);
            const userSnapshot = await get(userRef);
            if (!userSnapshot.exists()) return;
            
            const myData = userSnapshot.val();
            const failedAttempts = myData.failedHackAttempts || {};
            const attempts = failedAttempts[targetUsername] || { count: 0, lastAttempt: 0 };
            
            // Check if locked out
            const now = Date.now();
            const lockoutTime = 24 * 60 * 60 * 1000; // 24 hours
            if (attempts.count >= 5 && (now - attempts.lastAttempt) < lockoutTime) {
                const hoursLeft = Math.ceil((lockoutTime - (now - attempts.lastAttempt)) / (60 * 60 * 1000));
                showNotification(`Du är låst från att hacka ${targetUsername} i ${hoursLeft} timmar till!`, true);
                closeAttackModal();
                return;
            }
            
            // Reset attempts if 24h has passed
            if (attempts.count >= 5 && (now - attempts.lastAttempt) >= lockoutTime) {
                attempts.count = 0;
            }
            
            const activeDefenses = getActiveDefenses(target.defenses || []);
            
            // Check for 2FA defense
            if (activeDefenses.includes('2fa') && Math.random() < 0.3) {
                showNotification('2FA blockerade ditt hack-försök!', true);
                addActivityLog(currentUsername, `Försökte hacka ${targetUsername} men blockades av 2FA`);
                
                if (activeDefenses.includes('honeypot')) {
                    addActivityLog(targetUsername, `${currentUsername} försökte hacka dig men blockades av 2FA`);
                }
                
                closeAttackModal();
                return;
            }

            if (guess === target.password) {
                // SUCCESS! Steal all their creds and mark as hacked
                const stolenCreds = target.creds || 0;
                
                // ANTI-CHEAT: Log stolen creds as HACK source (excluded from anti-cheat limits!)
                ANTI_CHEAT.logCredGain(stolenCreds, 'hack');
                ANTI_CHEAT.logAction('successful_hack');
                
                // NO anti-cheat check here - legitimate hacks should never trigger bans!
                
                await update(targetRef, {
                    creds: 0,
                    security: 0,
                    hacked: true,
                    hackedBy: currentUsername,
                    hackedAt: Date.now()
                });

                // CRITICAL: Read current hacker creds from Firebase first!
                const hackerSnapshot = await get(userRef);
                if (!hackerSnapshot.exists()) {
                    closeAttackModal();
                    return;
                }
                
                const currentHackerCreds = hackerSnapshot.val().creds || 0;
                const currentSuccessfulHacks = hackerSnapshot.val().successfulHacks || 0;
                
                // Reset failed attempts on success
                const updatedFailedAttempts = { ...failedAttempts };
                delete updatedFailedAttempts[targetUsername];
                
                await update(userRef, {
                    creds: currentHackerCreds + stolenCreds,
                    successfulHacks: currentSuccessfulHacks + 1,
                    failedHackAttempts: updatedFailedAttempts
                });

                addActivityLog(currentUsername, `HACKADE ${targetUsername}! Stal ${formatNumber(stolenCreds)} creds! Kontot raderat.`);
                addActivityLog(targetUsername, `DITT KONTO BLEV HACKAT AV ${currentUsername}! Kontot kommer raderas vid nästa inloggning.`);

                showNotification(`LYCKAT HACK! Stal ${formatNumber(stolenCreds)} creds från ${targetUsername}! Deras konto är nu raderat!`);
                closeAttackModal();
            } else {
                // Failed attempt - increment counter
                attempts.count += 1;
                attempts.lastAttempt = now;
                
                const updatedFailedAttempts = { ...failedAttempts, [targetUsername]: attempts };
                await update(userRef, {
                    failedHackAttempts: updatedFailedAttempts
                });
                
                if (attempts.count >= 5) {
                    showNotification(`FEL LÖSENORD! Du har misslyckats 5 gånger och är nu låst i 24 timmar!`, true);
                } else {
                    showNotification(`Fel lösenord! (${attempts.count}/5 försök - vid 5 låses du i 24h)`, true);
                }
                
                const activeDefenses = getActiveDefenses(target.defenses || []);
                
                if (activeDefenses.includes('honeypot')) {
                    addActivityLog(targetUsername, `${currentUsername} försökte hacka dig (felaktigt försök ${attempts.count}/5)`);
                }

                if (activeDefenses.includes('counter')) {
                    // Counter-hack steals some creds
                    // CRITICAL: Read current hacker creds from Firebase first
                    const userRef = ref(db, `users/${currentUsername}`);
                    const hackerSnapshot = await get(userRef);
                    if (!hackerSnapshot.exists()) return;
                    
                    const currentHackerCreds = hackerSnapshot.val().creds || 0;
                    const stolen = Math.min(20, currentHackerCreds);
                    
                    await update(userRef, {
                        creds: currentHackerCreds - stolen
                    });

                    // Also read target's current creds
                    const targetSnapshot = await get(targetRef);
                    if (targetSnapshot.exists()) {
                        const currentTargetCreds = targetSnapshot.val().creds || 0;
                        await update(targetRef, {
                            creds: currentTargetCreds + stolen
                        });
                    }

                    addActivityLog(currentUsername, `Counter-Hack stal ${stolen} creds från dig!`);
                    addActivityLog(targetUsername, `Counter-Hack stal ${stolen} creds från ${currentUsername}`);
                }

                addActivityLog(currentUsername, `Misslyckades med att hacka ${targetUsername}`);
            }
        };

        window.gatherClues = async function(targetUsername) {
            const modal = document.getElementById('attackModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');

            modalTitle.textContent = `Samla Ledtrådar: ${targetUsername}`;
            
            modalContent.innerHTML = `
                <h3>Välj Attack-Nivå:</h3>
                
                <div style="margin: 20px 0;">
                    <button class="btn" onclick="executeClueGathering('${targetUsername}', 1)" style="margin: 10px 0;">
                        Nivå 1: Grundläggande Spaning (25 creds)
                        <br><small>Visar: användarnamn, senaste inloggning, antal försvar</small>
                    </button>
                    
                    <button class="btn" onclick="executeClueGathering('${targetUsername}', 2)" style="margin: 10px 0;">
                        Nivå 2: Nätverksanalys (50 creds)
                        <br><small>Visar: lösenordslängd, om det är mest siffror eller bokstäver</small>
                    </button>
                    
                    <button class="btn" onclick="executeClueGathering('${targetUsername}', 3)" style="margin: 10px 0;">
                        Nivå 3: Social Engineering (80 creds)
                        <br><small>Minispel - Visar EN position (t.ex. "position 3 är en siffra")</small>
                    </button>
                    
                    <button class="btn" onclick="executeClueGathering('${targetUsername}', 4)" style="margin: 10px 0;">
                        Nivå 4: Djup Infiltration (150 creds)
                        <br><small>Svårt pussel - Visar EN bokstav/siffra och position</small>
                    </button>
                    
                    <button class="btn" onclick="executeClueGathering('${targetUsername}', 5)" style="margin: 10px 0;">
                        Nivå 5: Zero-Day Exploit (300 creds)
                        <br><small>Visar 2 tecken och deras positioner</small>
                    </button>
                </div>
            `;

            modal.classList.add('active');
        };

        window.executeClueGathering = async function(targetUsername, level) {
            const costs = [0, 25, 50, 80, 150, 300];
            const cost = costs[level];

            // CRITICAL: Read current creds from Firebase first
            const userRef = ref(db, `users/${currentUsername}`);
            const userSnapshot = await get(userRef);
            if (!userSnapshot.exists()) return;
            
            const currentCreds = userSnapshot.val().creds || 0;

            if (currentCreds < cost) {
                showNotification('Inte tillräckligt med creds!', true);
                return;
            }

            const targetRef = ref(db, `users/${targetUsername}`);
            const targetSnapshot = await get(targetRef);

            if (!targetSnapshot.exists()) {
                showNotification('Användare finns inte längre!', true);
                closeAttackModal();
                return;
            }

            const target = targetSnapshot.val();
            let clue = '';

            const activeDefenses = getActiveDefenses(target.defenses || []);

            // Check if decoy system makes clue fake
            const isFakeClue = activeDefenses.includes('decoy') && Math.random() < 0.5;

            if (level === 1) {
                clue = `Användarnamn: ${target.username}, Senast inloggad: ${new Date(target.lastLogin).toLocaleString('sv')}, Försvar: ${activeDefenses.length}`;
            } else if (level === 2) {
                const password = target.password;
                const numDigits = (password.match(/[0-9]/g) || []).length;
                const numLetters = (password.match(/[a-z]/gi) || []).length;
                const type = numDigits > numLetters ? 'mest siffror' : 'mest bokstäver';
                
                if (isFakeClue) {
                    clue = `Lösenordslängd: ${Math.floor(Math.random() * 8) + 1} tecken, Innehåller: ${Math.random() < 0.5 ? 'mest siffror' : 'mest bokstäver'}`;
                } else {
                    clue = `Lösenordslängd: ${password.length} tecken, Innehåller: ${type}`;
                }
            } else if (level === 3) {
                // Simple minigame - math question
                const num1 = Math.floor(Math.random() * 10) + 1;
                const num2 = Math.floor(Math.random() * 10) + 1;
                
                showPrompt(`Minispel: Vad är ${num1} + ${num2}?`, async function(answer) {
                    if (parseInt(answer) === num1 + num2) {
                        const password = target.password;
                        const pos = Math.floor(Math.random() * password.length);
                        const char = password[pos];
                        const isDigit = /[0-9]/.test(char);
                        
                        if (isFakeClue) {
                            clue = `Position ${pos + 1} är en ${Math.random() < 0.5 ? 'siffra' : 'bokstav'}`;
                        } else {
                            clue = `Position ${pos + 1} är en ${isDigit ? 'siffra' : 'bokstav'}`;
                        }
                        
                        // Save clue and continue
                        await saveClueAndFinish(clue, cost, targetUsername, level, activeDefenses);
                    } else {
                        showNotification('Fel svar! Ingen ledtråd.', true);
                        if (activeDefenses.includes('alert')) {
                            addActivityLog(targetUsername, `${currentUsername} försökte samla ledtrådar (misslyckades med minispel)`);
                        }
                        
                        // CRITICAL: Read current creds from Firebase again
                        const currentCredsNow = (await get(userRef)).val()?.creds || 0;
                        
                        await update(userRef, {
                            creds: currentCredsNow - cost
                        });
                        addActivityLog(currentUsername, `Misslyckades med minispel mot ${targetUsername}, förlorade ${cost} creds`);
                        closeAttackModal();
                    }
                }, function() {
                    // Cancel
                    closeAttackModal();
                });
                return; // Don't continue - wait for prompt response
            } else if (level === 4) {
                const num1 = Math.floor(Math.random() * 20) + 10;
                const num2 = Math.floor(Math.random() * 20) + 10;
                
                showPrompt(`Svårt pussel: Vad är ${num1} * ${num2}?`, async function(answer) {
                    if (parseInt(answer) === num1 * num2) {
                        const password = target.password;
                        const pos = Math.floor(Math.random() * password.length);
                        const char = password[pos];
                        
                        if (isFakeClue) {
                            const fakeChars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                            const fakeChar = fakeChars[Math.floor(Math.random() * fakeChars.length)];
                            clue = `Position ${pos + 1} är '${fakeChar}'`;
                        } else {
                            clue = `Position ${pos + 1} är '${char}'`;
                        }
                        
                        // Save clue and continue
                        await saveClueAndFinish(clue, cost, targetUsername, level, activeDefenses);
                    } else {
                        showNotification('Fel svar! Ingen ledtråd.', true);
                        if (activeDefenses.includes('alert')) {
                            addActivityLog(targetUsername, `${currentUsername} försökte samla ledtrådar (misslyckades med pussel)`);
                        }
                        
                        // CRITICAL: Read current creds from Firebase again
                        const currentCredsNow = (await get(userRef)).val()?.creds || 0;
                        
                        await update(userRef, {
                            creds: currentCredsNow - cost
                        });
                        addActivityLog(currentUsername, `Misslyckades med pussel mot ${targetUsername}, förlorade ${cost} creds`);
                        closeAttackModal();
                    }
                }, function() {
                    // Cancel
                    closeAttackModal();
                });
                return; // Don't continue - wait for prompt response
            } else if (level === 5) {
                const password = target.password;
                const positions = [];
                while (positions.length < 2 && positions.length < password.length) {
                    const pos = Math.floor(Math.random() * password.length);
                    if (!positions.includes(pos)) positions.push(pos);
                }
                
                if (isFakeClue) {
                    const fakeChars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                    clue = positions.map(p => `Position ${p + 1} är '${fakeChars[Math.floor(Math.random() * fakeChars.length)]}'`).join(', ');
                } else {
                    clue = positions.map(p => `Position ${p + 1} är '${password[p]}'`).join(', ');
                }
            }

            // Save clue and finish (helper function used by prompts too)
            await saveClueAndFinish(clue, cost, targetUsername, level, activeDefenses);
        };

        // Helper function to save clue and complete clue gathering
        async function saveClueAndFinish(clue, cost, targetUsername, level, activeDefenses) {
            const userRef = ref(db, `users/${currentUsername}`);
            
            // Save clue
            const currentClues = userData.clues || {};
            const targetClues = currentClues[targetUsername] || [];
            targetClues.push(clue);
            currentClues[targetUsername] = targetClues;

            // CRITICAL: Read current creds from Firebase again
            const currentCredsNow = (await get(userRef)).val()?.creds || 0;

            await update(userRef, {
                clues: currentClues,
                creds: currentCredsNow - cost
            });

            if (activeDefenses.includes('alert')) {
                addActivityLog(targetUsername, `${currentUsername} samlade ledtrådar om dig (Nivå ${level})`);
            }

            addActivityLog(currentUsername, `Samlade ledtråd om ${targetUsername}: ${clue}`);
            showNotification(`Ledtråd erhållen: ${clue}`);
            closeAttackModal();
        };

        function updateMyDefenses() {
            const defensesDiv = document.getElementById('myDefenses');
            let userDefenses = userData.defenses || [];
            
            // Migrate old format to new format
            userDefenses = userDefenses.map(d => {
                if (typeof d === 'string') {
                    // Old format - mark as expired
                    return { id: d, activatedAt: 0, expiresAt: 0 };
                }
                return d;
            });
            
            const activeDefenses = getActiveDefenses(userDefenses);

            if (activeDefenses.length === 0) {
                defensesDiv.innerHTML = '<div class="empty-state">Du har inga aktiva försvar. Köp i butiken!</div>';
                return;
            }

            const now = Date.now();
            defensesDiv.innerHTML = userDefenses
                .filter(d => d.expiresAt > now) // Only show active defenses
                .map(defense => {
                    const item = shopItems.find(i => i.id === defense.id);
                    if (!item) return ''; // Skip if item not found
                    
                    const timeLeft = defense.expiresAt - now;
                    const seconds = Math.floor(timeLeft / 1000);
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                    
                    return `
                        <div class="defense-badge" style="border: 2px solid #0f0; padding: 15px; margin-bottom: 10px;">
                            <strong>${item.name}</strong>: ${item.description}
                            <div style="color: #0f0; margin-top: 5px; font-size: 14px;">
                                TID KVAR: ${timeStr}
                            </div>
                        </div>
                    `;
                })
                .join('');
                
            // Clear previous timer
            if (defensesUpdateTimer) {
                clearTimeout(defensesUpdateTimer);
            }
            
            // Only continue updating if account tab is active
            const accountTab = document.getElementById('accountTab');
            if (accountTab && accountTab.classList.contains('active')) {
                defensesUpdateTimer = setTimeout(updateMyDefenses, 1000);
            }
        }

        function updateActivityLog() {
            const logDiv = document.getElementById('activityLog');
            const logs = userData.activityLog || [];

            if (logs.length === 0) {
                logDiv.innerHTML = '<div class="empty-state">Ingen aktivitet än!</div>';
                return;
            }

            logDiv.innerHTML = logs.slice(-20).reverse().map(log => `
                <div class="log-entry">
                    <div class="timestamp">${new Date(log.timestamp).toLocaleString('sv')}</div>
                    <div>${log.message}</div>
                </div>
            `).join('');
        }

        async function addActivityLog(username, message) {
            const userRef = ref(db, `users/${username}`);
            const snapshot = await get(userRef);
            
            if (snapshot.exists()) {
                const user = snapshot.val();
                const logs = user.activityLog || [];
                logs.push({
                    message: message,
                    timestamp: Date.now()
                });

                // Keep only last 50 logs
                const trimmedLogs = logs.slice(-50);

                await update(userRef, {
                    activityLog: trimmedLogs
                });
            }
        }

        window.changePassword = async function() {
            const newPass = document.getElementById('newPassword').value.trim();

            if (!newPass) {
                showNotification('Ange ett nytt lösenord!', true);
                return;
            }

            if (newPass.length > 8) {
                showNotification('Lösenord får max vara 8 tecken!', true);
                return;
            }

            if (!/^[a-z0-9]+$/i.test(newPass)) {
                showNotification('Lösenord får bara innehålla a-z och 0-9!', true);
                return;
            }

            // CRITICAL: Read current creds from Firebase first
            const myUserRef = ref(db, `users/${currentUsername}`);
            const mySnapshot = await get(myUserRef);
            if (!mySnapshot.exists()) return;
            
            const currentCreds = mySnapshot.val().creds || 0;

            if (currentCreds < 500) {
                showNotification('Du behöver 500 creds för att byta lösenord!', true);
                return;
            }

            // Get all users and remove clues about current user
            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            if (snapshot.exists()) {
                const updates = {};
                
                snapshot.forEach(childSnapshot => {
                    const username = childSnapshot.key;
                    const user = childSnapshot.val();
                    
                    if (username !== currentUsername && user.clues && user.clues[currentUsername]) {
                        // Remove clues about current user from this user
                        updates[`users/${username}/clues/${currentUsername}`] = null;
                    }
                });

                // Update current user's password and deduct creds
                updates[`users/${currentUsername}/password`] = newPass;
                updates[`users/${currentUsername}/creds`] = currentCreds - 500;

                await update(ref(db), updates);
            }

            addActivityLog(currentUsername, 'Bytte lösenord för 500 creds - alla ledtrådar om dig raderades');
            showNotification('Lösenord uppdaterat! Alla ledtrådar om dig är borta.');
            document.getElementById('newPassword').value = '';
        };

        window.closeAttackModal = function() {
            document.getElementById('attackModal').classList.remove('active');
        };

        window.switchTab = function(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Reload specific content when switching tabs
            if (tabName === 'earn') {
                loadEarnUpgrades();
            } else if (tabName === 'leaderboard') {
                loadLeaderboard();
            } else if (tabName === 'shop') {
                loadShop(); // This will restart the shop timer
            } else if (tabName === 'account') {
                updateMyDefenses(); // This will restart the defenses timer
            }
        };

        function showNotification(message, isError = false) {
            const notif = document.createElement('div');
            notif.className = 'notification' + (isError ? ' error' : '');
            notif.textContent = message;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.remove();
            }, 3000);
        }

        // OPERATOR PANEL FUNCTIONS
        window.showOperatorPrompt = function() {
            document.getElementById('operatorPasswordModal').classList.add('active');
            document.getElementById('operatorPasswordInput').value = '';
            setTimeout(() => {
                document.getElementById('operatorPasswordInput').focus();
            }, 100);
        };

        window.closeOperatorPasswordModal = function() {
            document.getElementById('operatorPasswordModal').classList.remove('active');
            document.getElementById('operatorPasswordInput').value = '';
        };

        window.checkOperatorPassword = function() {
            const password = document.getElementById('operatorPasswordInput').value;
            
            // Multi-layer obfuscation
            const _0x4a2b = ['YWRtaW4yNjc4YWRtaW4='];
            const _0x8f3c = (s) => atob(s);
            const _0x2d9e = [97,100,109,105,110,50,54,55,56,97,100,109,105,110].map(c=>String.fromCharCode(c)).join('');
            const _0x7b1a = String.fromCharCode(0x61,0x64,0x6d,0x69,0x6e,0x32,0x36,0x37,0x38,0x61,0x64,0x6d,0x69,0x6e);
            const _0x9c4f = (_0x8f3c(_0x4a2b[0]) === _0x2d9e && _0x7b1a === _0x2d9e) ? _0x7b1a : '';
            
            if (password === _0x9c4f) {
                closeOperatorPasswordModal();
                openOperatorPanel();
            } else {
                showNotification('Fel lösenord!', true);
                document.getElementById('operatorPasswordInput').value = '';
                document.getElementById('operatorPasswordInput').focus();
            }
        };

        // Allow Enter key to submit password
        document.addEventListener('DOMContentLoaded', function() {
            const passwordInput = document.getElementById('operatorPasswordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        checkOperatorPassword();
                    }
                });
            }
        });
        
        // System integrity checks
        const _validateAuth = (k) => {
            const _h = [118,101,114,54,116,51,50,48,49,50];
            return k === _h.map(x=>String.fromCharCode(x)).join('');
        };
        
        const _verifyAccess = (p) => {
            const _s = 'YWRtaW5hZG1pbg==';
            return btoa(p) === _s;
        };
        
        const _checkCredentials = (u) => {
            const _d = {s: 'c3VwZXI=', p: 'cGFzcw=='};
            return atob(_d.s) + atob(_d.p) === u;
        };

        function openOperatorPanel() {
            document.getElementById('operatorPanel').classList.add('active');
            loadOperatorStats();
        }

        window.closeOperatorPanel = function() {
            document.getElementById('operatorPanel').classList.remove('active');
        };

        async function loadOperatorStats() {
            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            let totalUsers = 0;
            let activeUsers = 0;
            let hackedUsers = 0;
            let totalCreds = 0;

            if (snapshot.exists()) {
                snapshot.forEach(childSnapshot => {
                    const user = childSnapshot.val();
                    if (user.username !== 'undefined' && user.password !== 'undefined') {
                        totalUsers++;
                        if (!user.hacked) activeUsers++;
                        if (user.hacked) hackedUsers++;
                        totalCreds += user.creds || 0;
                    }
                });
            }

            document.getElementById('opTotalUsers').textContent = totalUsers;
            document.getElementById('opActiveUsers').textContent = activeUsers;
            document.getElementById('opHackedUsers').textContent = hackedUsers;
            document.getElementById('opTotalCreds').textContent = totalCreds.toLocaleString();
        }

        window.loadAllUsers = async function() {
            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            const usersList = document.getElementById('opUsersList');
            usersList.innerHTML = '<div style="text-align: center; padding: 20px;">Laddar...</div>';

            if (!snapshot.exists()) {
                usersList.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.5;">Inga användare hittades</div>';
                return;
            }

            const users = [];
            snapshot.forEach(childSnapshot => {
                const username = childSnapshot.key;
                const user = childSnapshot.val();
                
                if (user.username !== 'undefined' && user.password !== 'undefined') {
                    users.push({ username, ...user });
                }
            });

            users.sort((a, b) => (b.creds || 0) - (a.creds || 0));

            usersList.innerHTML = users.map(user => `
                <div class="user-card ${user.hacked ? 'hacked' : ''}" onclick="showUserDetails('${user.username}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${user.username}</strong> ${user.hacked ? '[HACKAD]' : '[AKTIV]'}
                            <div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">
                                Lösenord: ${user.password} | Creds: ${(user.creds || 0).toLocaleString()}
                            </div>
                        </div>
                        <button class="btn btn-danger" onclick="event.stopPropagation(); deleteUser('${user.username}')" 
                                style="width: auto; padding: 5px 15px; font-size: 12px;">
                            RADERA
                        </button>
                    </div>
                </div>
            `).join('');
        };

        window.showUserDetails = function(username) {
            showCriticalMessage(
                `ANVÄNDARE: ${username}`,
                'Öppna Firebase Console för detaljerad information.',
                'none' // Don't reload, just close
            );
        };

        window.deleteUser = async function(username) {
            showConfirm(`Är du säker på att du vill radera ${username}?`, async function() {
                const userRef = ref(db, `users/${username}`);
                await set(userRef, null);
                
                showNotification(`${username} raderad!`);
                loadAllUsers();
                loadOperatorStats();
            }, null, true); // true = operator panel (inverted colors)
        };

        window.resetAllPasswords = async function() {
            showConfirm('Är du säker? Detta återställer ALLA lösenord till "password"!', async function() {

            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            if (snapshot.exists()) {
                const updates = {};
                snapshot.forEach(childSnapshot => {
                    const username = childSnapshot.key;
                    const user = childSnapshot.val();
                    if (user.username !== 'undefined') {
                        updates[`users/${username}/password`] = 'password';
                    }
                });
                await update(ref(db), updates);
            }

            showNotification('Alla lösenord återställda!');
            loadAllUsers();
            }, null, true); // true = operator panel (inverted colors)
        };

        window.giveAllCreds = async function() {
            showConfirm('Ge alla användare 10,000 creds?', async function() {
                const usersRef = ref(db, 'users');
                const snapshot = await get(usersRef);

                if (snapshot.exists()) {
                    const updates = {};
                    snapshot.forEach(childSnapshot => {
                        const username = childSnapshot.key;
                        const user = childSnapshot.val();
                        if (user.username !== 'undefined') {
                            updates[`users/${username}/creds`] = (user.creds || 0) + 10000;
                        }
                    });
                    await update(ref(db), updates);
                }

                showNotification('10,000 creds tillagda till alla!');
                loadAllUsers();
                loadOperatorStats();
            }, null, true); // true = operator panel (inverted colors)
        };

        window.cleanupCorruptAccounts = async function() {
            showConfirm('Radera alla korrupta konton (undefined användare)?', async function() {

            const usersRef = ref(db, 'users');
            const snapshot = await get(usersRef);

            if (!snapshot.exists()) return;

            const updates = {};
            let count = 0;

            snapshot.forEach(childSnapshot => {
                const username = childSnapshot.key;
                const user = childSnapshot.val();
                
                if (user.username === 'undefined' || user.password === 'undefined' || 
                    username === 'undefined' || !user.username || !user.password) {
                    updates[`users/${username}`] = null;
                    count++;
                }
            });

            if (count > 0) {
                await update(ref(db), updates);
                showNotification(`${count} korrupta konton raderade!`);
                loadAllUsers();
                loadOperatorStats();
            } else {
                showNotification('Inga korrupta konton hittades');
            }
            }, null, true); // true = operator panel (inverted colors)
        };

        window.unbanUser = async function() {
            const username = document.getElementById('unbanUsername').value.trim();
            
            if (!username) {
                showNotification('Ange användarnamn!', true);
                return;
            }
            
            showConfirm(`Unbanna och återställ konto för ${username}?`, async function() {
                const userRef = ref(db, `users/${username}`);
                const snapshot = await get(userRef);
                
                if (!snapshot.exists()) {
                    showNotification(`Användare ${username} finns inte!`, true);
                    return;
                }
                
                const userData = snapshot.val();
                
                // Check if actually banned
                if (!userData.banned && !userData.hacked) {
                    showNotification(`${username} är inte bannad!`, true);
                    return;
                }
                
                // Restore account
                await update(userRef, {
                    banned: false,
                    hacked: false,
                    security: 100
                });
                
                showNotification(`${username} har unbannats och återställts!`);
                document.getElementById('unbanUsername').value = '';
                loadAllUsers();
                loadOperatorStats();
                
                addActivityLog(username, 'Konto återställt av operator');
            }, null, true); // true = operator panel (inverted colors)
        };

        window.setUserCreds = async function() {
            const username = document.getElementById('setCredsUsername').value.trim();
            const amount = parseInt(document.getElementById('setCredsAmount').value);

            if (!username) {
                showNotification('Ange ett användarnamn!', true);
                return;
            }

            if (isNaN(amount) || amount < 0) {
                showNotification('Ange ett giltigt antal creds (0 eller högre)!', true);
                return;
            }

            const userRef = ref(db, `users/${username}`);
            const snapshot = await get(userRef);

            if (!snapshot.exists()) {
                showNotification(`Användare "${username}" finns inte!`, true);
                return;
            }

            await update(userRef, {
                creds: amount
            });

            showNotification(`${username} har nu ${amount.toLocaleString()} creds!`);
            document.getElementById('setCredsUsername').value = '';
            document.getElementById('setCredsAmount').value = '';
            loadAllUsers();
            loadOperatorStats();
        };
    </script>
</body>
</html>